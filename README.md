# Data Structures and Algorithms Practice

A comprehensive collection of DSA problems and solutions organized by patterns and problem types.

## ğŸ“Š DSA Progress Tracker

### âœ… Completed
- Arrays
- Strings
- Two Pointers
- Sliding Window
- Hash Maps
- Stack
- Queue
- Linked List

### ğŸ”„ In Progress
- Trees
- Graphs
- Recursion

### â­ï¸ Next
- Dynamic Programming
- Greedy
- Math

## ğŸ“š Repository Structure

```
dsa-practice/
â”œâ”€â”€ arrays/                    # Array-based problems
â”œâ”€â”€ strings/                   # String manipulation problems
â”œâ”€â”€ two-pointers/              # Two pointer technique
â”œâ”€â”€ sliding-window/            # Sliding window problems
â”œâ”€â”€ hashmaps/                  # Hash map problems
â”œâ”€â”€ stack/                     # Stack problems
â”œâ”€â”€ queue/                     # Queue problems
â”œâ”€â”€ linked-list/               # Linked list problems
â”œâ”€â”€ trees/                     # Tree problems (BST, binary trees)
â”œâ”€â”€ graphs/                    # Graph problems (DFS, BFS)
â”œâ”€â”€ recursion/                 # Recursion problems
â”œâ”€â”€ dynamic-programming/       # DP problems
â”œâ”€â”€ greedy/                    # Greedy algorithm problems
â”œâ”€â”€ math/                      # Mathematical problems
â”œâ”€â”€ solutions_v2/              # Your personal solutions
â””â”€â”€ README.md
```

## ğŸš€ Getting Started

### Prerequisites
- Python 3.6 or higher

### Running Examples

Each problem file can be run independently:

```bash
# Run a problem solution
python arrays/two_sum.py
python trees/invert_binary_tree.py
python dynamic-programming/climbing_stairs.py
```

## ğŸ“ Problem Format

Every problem follows this structure:

```python
# problem: Problem Name
# approach: Solution approach
# time: Time complexity
# space: Space complexity

"""
Detailed problem description
"""

def solution():
    # Implementation
    pass
```

## ğŸ“– Categories

### Arrays
Core array manipulation problems
- Two Sum
- Maximum Subarray (Kadane's Algorithm)
- Best Time to Buy and Sell Stock

### Strings
String processing and pattern matching
- Valid Palindrome
- Valid Anagram
- Longest Substring Without Repeating Characters

### Two Pointers
Problems using two pointer technique
- Container With Most Water
- Three Sum
- Valid Palindrome

### Sliding Window
Subarray/substring problems
- Longest Substring Without Repeating Characters
- Maximum Sum Subarray of Size K

### Hash Maps
Problems using hash maps for O(1) lookups
- Two Sum
- Group Anagrams
- Longest Consecutive Sequence

### Stack
LIFO data structure problems
- Valid Parentheses
- Min Stack
- Evaluate Reverse Polish Notation

### Queue
FIFO data structure problems
- Implement Queue using Stacks
- Moving Average from Data Stream

### Linked List
Linked list manipulation
- Reverse Linked List
- Linked List Cycle
- Merge Two Sorted Lists

### Trees
Binary tree and BST problems
- Invert Binary Tree
- Maximum Depth of Binary Tree
- Validate Binary Search Tree

### Graphs
Graph traversal and algorithms
- Number of Islands
- Clone Graph
- Course Schedule

### Recursion
Recursive problem solving
- Fibonacci Sequence
- Tower of Hanoi
- Factorial

### Dynamic Programming
Optimization problems with overlapping subproblems
- Climbing Stairs
- Coin Change
- Longest Common Subsequence

### Greedy
Problems with greedy choice property
- Jump Game
- Best Time to Buy and Sell Stock II
- Gas Station

### Math
Mathematical and number theory problems
- Reverse Integer
- Palindrome Number
- Power of Two


## ğŸ¯ Learning Path

### Beginner
1. Start with **Arrays** and **Strings**
2. Learn **Two Pointers** technique
3. Practice **Stack** and **Queue** problems
4. Master **Hash Maps** for fast lookups

### Intermediate
5. Dive into **Linked Lists**
6. Explore **Trees** (especially BST)
7. Learn **Recursion** fundamentals
8. Practice **Sliding Window** problems

### Advanced
9. Master **Graphs** (DFS, BFS)
10. Study **Dynamic Programming**
11. Learn **Greedy** algorithms
12. Solve **Math** problems

## ğŸ”„ Practice Workflow

1. **Read** the problem in the category folder
2. **Attempt** your solution in `solutions_v2/` folder
3. **Compare** with the reference solution
4. **Analyze** time and space complexity
5. **Iterate** and optimize

## ğŸ› ï¸ Personal Solutions

Use the `solutions_v2/` folder to implement your own solutions:

```bash
# Your solution
solutions_v2/arrays/two_sum.py

# Reference solution
arrays/two_sum.py
```

This allows you to:
- Practice implementation
- Compare approaches
- Track your progress
- Build your portfolio

## ğŸ“Š Time Complexity Quick Reference

| Data Structure | Access | Search | Insertion | Deletion |
|---------------|--------|--------|-----------|----------|
| Array         | O(1)   | O(n)   | O(n)      | O(n)     |
| Linked List   | O(n)   | O(n)   | O(1)      | O(1)     |
| Stack         | O(n)   | O(n)   | O(1)      | O(1)     |
| Queue         | O(n)   | O(n)   | O(1)      | O(1)     |
| BST (avg)     | O(log n)| O(log n)| O(log n) | O(log n)|
| Hash Table    | N/A    | O(1)   | O(1)      | O(1)     |

## ğŸ¤ Contributing

This is a personal practice repository. Feel free to fork and customize for your own learning!

## ğŸ“„ License

This project is open source and available for educational purposes.

## ğŸ“š Resources

- [LeetCode](https://leetcode.com/) - Practice platform
- [NeetCode](https://neetcode.io/) - Curated problem list
- [Big O Cheat Sheet](https://www.bigocheatsheet.com/) - Complexity reference
- [Visualgo](https://visualgo.net/) - Algorithm visualizations
- [GeeksforGeeks](https://www.geeksforgeeks.org/) - Tutorials and explanations
